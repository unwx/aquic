mod server;
pub use server::*;


use std::borrow::Cow;
use std::cmp::Ordering;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::hash::{Hash, Hasher};
use std::ops::{Deref, DerefMut};
use std::time::Duration;

/// Max allowed connection ID length (RFC 9000).
pub const MAX_CID_LEN: usize = 20;


/// A Connection ID.
///
/// This struct holds the raw bytes of a connection ID.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ConnectionId(Bytes<MAX_CID_LEN>);

impl ConnectionId {
    /// Empty Connection ID.
    pub const EMPTY: Self = ConnectionId(Bytes::ZERO);

    /// Create a clone of Connection ID from slice.
    pub fn from_slice(slice: &[u8]) -> Self {
        Self(Bytes::from_slice(slice))
    }

    /// Returns connection ID as an immutable slice.
    pub fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }

    /// Returns connection ID as a mutable slice.
    pub fn as_mut(&mut self) -> &mut [u8] {
        self.0.as_mut()
    }

    /// Returns connection ID length in bytes.
    pub fn len(&self) -> usize {
        self.0.len
    }
}

impl Display for ConnectionId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        for byte in self.0 {
            write!(f, "{byte:02x}")?;
        }

        Ok(())
    }
}


/// The specified Connection ID is invalid.
#[derive(Debug, Clone)]
pub struct ConnIdError {
    pub original: ConnectionId,
    pub detail: Cow<'static, str>,
}

impl Display for ConnIdError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "connection-id '{}' is invalid: {}",
            &self.original, &self.detail
        )
    }
}

impl std::error::Error for ConnIdError {}


/// Metadata, that a specific Connection ID holds.
pub trait ConnIdMeta {
    /// Returns a CPU Core ID if this Connection ID is a Server ID, and it contains it.
    ///
    /// Core ID is **required** for server-side routing in thread-per-core async runtimes like monoio,
    /// where multiple sockets (socket per core) binds on the same port.
    ///
    /// Without it, it's impossible to determine which core should process the packet.
    ///
    /// On single-thread/work-stealing runtimes it is not mandatory.
    fn core_id(&self) -> Option<u16>;
}

/// A [ConnectionId] generator.
pub trait ConnIdGenerator {
    type Meta: ConnIdMeta;

    /// Generates a new CID.
    ///
    /// Connection IDs **must not** contain any information that can be used by
    /// an external observer to correlate them with other connection IDs for the same
    /// connection. They **must** have high entropy.
    fn generate_cid(&mut self) -> ConnectionId;

    /// Returns the length of a CID for connections created by this generator.
    ///
    /// Must not change in runtime.
    fn cid_len(&self) -> usize;

    /// Returns the lifetime of generated Connection IDs.
    ///
    /// Must not change in runtime.
    fn cid_lifetime(&self) -> Option<Duration>;

    /// Quickly determine whether `cid` could have been generated by this generator.
    /// This method is called only after `decrypt()`.
    ///
    /// False positives are permitted, but increase the cost of handling invalid packets.
    ///
    /// False negatives **are NOT permitted**.
    fn validate(&self, cid: &ConnectionId) -> bool;

    /// Decrypts a connection ID.
    ///
    /// Noop if it's not encrypted.
    fn decrypt(&self, cid: &mut ConnectionId) -> Result<(), ConnIdError>;

    /// Get metadata from a connection ID.
    fn parse(&self, cid: &ConnectionId) -> Result<Self::Meta, ConnIdError>;
}


#[derive(Debug, Copy, Clone)]
pub(crate) struct Bytes<const SIZE: usize> {
    bytes: [u8; SIZE],
    len: usize,
}

impl<const SIZE: usize> Bytes<SIZE> {
    pub const ZERO: Self = Self {
        bytes: [0u8; SIZE],
        len: 0,
    };

    pub fn from_slice(slice: &[u8]) -> Self {
        if slice.len() > SIZE {
            panic!(
                "unable to convert slice into u8 Array<{SIZE}>: slice is bigger ({}) than SIZE ({})",
                slice.len(),
                SIZE
            )
        }

        let array = Bytes::ZERO;
        array[..slice.len()].copy_from_slice(slice);
        array
    }

    pub fn into_inner(self) -> [u8; SIZE] {
        self.bytes
    }
}

impl<const SIZE: usize> Deref for Bytes<SIZE> {
    type Target = [u8; SIZE];

    fn deref(&self) -> &Self::Target {
        &self.bytes
    }
}

impl<const SIZE: usize> DerefMut for Bytes<SIZE> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.bytes
    }
}

impl<const SIZE: usize> PartialEq for Bytes<SIZE> {
    fn eq(&self, other: &Self) -> bool {
        self[..self.len] == other[..other.len]
    }
}

impl<const SIZE: usize> Eq for Bytes<SIZE> {}

impl<const SIZE: usize> PartialOrd for Bytes<SIZE> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self[..self.len].partial_cmp(&other[..other.len])
    }
}

impl<const SIZE: usize> Ord for Bytes<SIZE> {
    fn cmp(&self, other: &Self) -> Ordering {
        self[..self.len].cmp(&other[..other.len])
    }
}

impl<const SIZE: usize> Hash for Bytes<SIZE> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write(&self[..self.len])
    }
}
