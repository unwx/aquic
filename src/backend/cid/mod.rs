mod common;

pub use common::*;

conditional! {
    feature = "server-util",

    mod server;
}


use crate::conditional;
use crate::util::ArrayVec;
use std::borrow::Cow;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::hash::{Hash, Hasher};
use std::time::Duration;

/// Max allowed connection ID length (RFC 9000).
pub const MAX_CID_LEN: usize = 20;


/// A Connection ID.
///
/// This struct holds the raw bytes of a connection ID.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ConnectionId(ArrayVec<u8, MAX_CID_LEN>);

impl ConnectionId {
    /// Empty Connection ID.
    pub const EMPTY: Self = ConnectionId(ArrayVec::zeroed());

    /// Create a clone of Connection ID from slice.
    pub fn from_slice(slice: &[u8]) -> Self {
        Self(ArrayVec::from_slice(slice))
    }

    /// Returns connection ID as an immutable slice.
    pub fn as_ref(&self) -> &[u8] {
        self.0.as_slice()
    }

    /// Returns connection ID as a mutable slice.
    pub fn as_mut(&mut self) -> &mut [u8] {
        self.0.as_slice_mut()
    }

    /// Returns connection ID length in bytes.
    pub fn len(&self) -> usize {
        self.0.len()
    }
}

impl Display for ConnectionId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        for byte in self.0.as_slice() {
            write!(f, "{byte:02x}")?;
        }

        Ok(())
    }
}


/// The specified Connection ID is invalid.
#[derive(Debug, Clone)]
pub struct ConnIdError {
    pub original: ConnectionId,
    pub detail: Cow<'static, str>,
}

impl Display for ConnIdError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "connection-id '{}' is invalid: {}",
            &self.original, &self.detail
        )
    }
}

impl std::error::Error for ConnIdError {}


/// Metadata, that a specific Connection ID holds.
pub trait ConnIdMeta {
    /// Returns a CPU Core ID if this Connection ID is a Server ID, and it contains it.
    ///
    /// Core ID is **required** for server-side routing in thread-per-core async runtimes like monoio,
    /// where multiple sockets (socket per core) binds on the same port.
    ///
    /// Without it, it's impossible to determine which core should process the packet.
    ///
    /// On single-thread/work-stealing runtimes it is not necessary.
    fn core_id(&self) -> Option<u16>;
}

/// Noop implementation of [ConnIdMeta].
#[derive(Debug, Copy, Clone)]
pub struct NoopConnIdMeta;

impl ConnIdMeta for NoopConnIdMeta {
    fn core_id(&self) -> Option<u16> {
        None
    }
}


/// A [ConnectionId] generator.
pub trait ConnIdGenerator: Send {
    // Some QUIC implementations (like quinn-proto) require ConnIdGenerators to be Send + Sync.
    // Therefore, `Send` requirement is mandatory...

    type Meta: ConnIdMeta;

    /// Generates a new CID.
    ///
    /// Connection IDs **must not** contain any information that can be used by
    /// an external observer to correlate them with other connection IDs for the same
    /// connection. They **must** have high entropy.
    fn generate_cid(&mut self) -> ConnectionId;

    /// Returns the length of a CID for connections created by this generator.
    ///
    /// Expected to be constant.
    fn cid_len(&self) -> usize;

    /// Returns the lifetime of generated Connection IDs.
    ///
    /// Expected to be constant.
    fn cid_lifetime(&self) -> Option<Duration>;

    /// Quickly determine whether `cid` could have been generated by this generator.
    ///
    /// False positives are permitted, but increase the cost of handling invalid packets.
    ///
    /// False negatives **are NOT permitted**.
    fn validate(&self, cid: &ConnectionId) -> bool;

    /// Decrypts a connection ID.
    ///
    /// Noop if it's not encrypted.
    fn decrypt(&self, cid: &mut ConnectionId) -> Result<(), ConnIdError>;

    /// Get metadata from a connection ID.
    fn parse(&self, cid: &ConnectionId) -> Result<Self::Meta, ConnIdError>;
}
