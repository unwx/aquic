mod common;

pub use common::*;
use smallvec::SmallVec;

conditional! {
    feature = "server-util",

    mod server;
    pub use server::*;
}


use crate::conditional;
use std::borrow::Cow;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::hash::Hash;

/// Max allowed connection ID length (RFC 9000).
pub const MAX_CID_LEN: usize = 20;


/// A Connection ID.
///
/// This struct holds the raw bytes of a connection ID.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ConnectionId(SmallVec<[u8; MAX_CID_LEN]>);

impl ConnectionId {
    /// Create a clone of Connection ID from slice.
    pub fn from_slice(slice: &[u8]) -> Self {
        Self(SmallVec::from_slice(slice))
    }

    /// Returns connection ID as an immutable slice.
    pub fn as_slice(&self) -> &[u8] {
        self.0.as_slice()
    }

    /// Returns connection ID as a mutable slice.
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        self.0.as_mut_slice()
    }

    /// Returns connection ID length in bytes.
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns `true` if connection ID is empty.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

impl Display for ConnectionId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        for byte in self.0.as_slice() {
            write!(f, "{byte:02x}")?;
        }

        Ok(())
    }
}


/// The specified Connection ID is invalid.
#[derive(Debug, Clone)]
pub struct IdError {
    pub original: ConnectionId,
    pub detail: Cow<'static, str>,
}

impl Display for IdError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "connection-id '{}' is invalid: {}",
            &self.original, &self.detail
        )
    }
}

impl std::error::Error for IdError {}


/// Metadata, that a specific Connection ID holds.
pub trait ConnectionIdMeta {
    /// Returns a CPU Core ID if this Connection ID is a Server ID, and it contains it.
    ///
    /// Core ID is **required** for server-side routing in thread-per-core async runtimes like monoio,
    /// where multiple sockets (socket per core) binds on the same port.
    ///
    /// Without it, it's impossible to determine which core should process the packet.
    ///
    /// On single-thread/work-stealing runtimes it is not necessary.
    fn core_id(&self) -> Option<u16>;
}

/// Noop implementation of [ConnIdMeta].
#[derive(Debug, Copy, Clone)]
pub struct NoopIdMeta;

impl ConnectionIdMeta for NoopIdMeta {
    fn core_id(&self) -> Option<u16> {
        None
    }
}


/// A [ConnectionId] generator.
pub trait ConnectionIdGenerator: Send {
    // Some QUIC implementations (like quinn-proto) require ConnIdGenerators to be Send + Sync.
    // Therefore, `Send` requirement is mandatory...

    type Meta: ConnectionIdMeta;

    /// Generates a new CID.
    ///
    /// Connection IDs **must not** contain any information that can be used by
    /// an external observer to correlate them with other connection IDs for the same
    /// connection. They **must** have high entropy.
    fn generate(&mut self) -> ConnectionId;

    /// Returns the length of a CID for connections created by this generator.
    ///
    /// Expected to be constant.
    fn cid_len(&self) -> usize;

    /// Quickly determine whether `cid` could have been generated by this generator.
    ///
    /// False positives are permitted, but increase the cost of handling invalid packets.
    ///
    /// False negatives **are NOT permitted**.
    fn validate(&self, cid: &ConnectionId) -> bool;

    /// Decrypts a connection ID.
    ///
    /// Noop if it's not encrypted.
    fn decrypt(&self, cid: &mut ConnectionId) -> Result<(), IdError>;

    /// Get metadata from a connection ID.
    fn parse(&self, cid: &ConnectionId) -> Result<Self::Meta, IdError>;
}
